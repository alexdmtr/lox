var byte;
var lastByte = "";

fun nextSymbol(callback) {
    var byte = readByte();

    if (byte == nil or byte == NEWLINE_CHAR)
        return false;
    callback(byte);

    lastByte = byte;
    return true;
}

fun hasNextLine() {
    return lastByte != nil;
}

fun resolveAutomaton(transition, predicate) {
    var length = 0;
    while (nextSymbol(transition))
        length = length + 1;

    if (predicate())
        print "Accepted";
    else
        print "Refused";
    return length;
}

fun main() {
    while (hasNextLine()) {
        var alpha = 0;
        var beta = 0;

        var transition = fun(symbol) {
            if (symbol == "a")
                alpha = alpha+1;
            if (symbol == "c")
                beta = beta+1;
        };

        var predicate = fun() {
            return (alpha - beta) % 3 == 0;
        };

        resolveAutomaton(transition, predicate);

    }
}

class Point {
    toString() {
        return "Point("+this.x+","+this.y+")";
    }

    translate(other) {
        var newPoint = Point();
        newPoint.x = this.x + other.x;
        newPoint.y = this.y + other.y;

        return newPoint;
    }
}

var p = Point();
p.x = 2;
p.y = 3;

var t = Point();
t.x = 1;
t.y = 2;

p = p.translate(t);
print p.toString();